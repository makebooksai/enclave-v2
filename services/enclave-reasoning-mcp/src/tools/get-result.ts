/**
 * Get Reasoning Result Tool
 *
 * Retrieves the final result from a reasoning session.
 */

import { Tool } from '@modelcontextprotocol/sdk/types.js';
import type { GetResultInput, GetResultOutput, QualityMetrics } from '../types.js';
import { getSession } from '../utils/session-store.js';

// ─────────────────────────────────────────────────────────────────────────────
// Tool Definition
// ─────────────────────────────────────────────────────────────────────────────

export const getResultTool: Tool = {
  name: 'get_reasoning_result',
  description: 'Get the final synthesized result from a reasoning session.',
  inputSchema: {
    type: 'object',
    properties: {
      session_id: {
        type: 'string',
        description: 'The session_id from start_reasoning_session',
      },
      format: {
        type: 'string',
        description: 'Output format',
        enum: ['markdown', 'json', 'structured'],
        default: 'markdown',
      },
      include_full_exchange: {
        type: 'boolean',
        description: 'Include the complete conversation history',
        default: false,
      },
    },
    required: ['session_id'],
  },
};

// ─────────────────────────────────────────────────────────────────────────────
// Handler
// ─────────────────────────────────────────────────────────────────────────────

export async function handleGetResult(
  args: Record<string, unknown>
): Promise<{ content: Array<{ type: string; text: string }> }> {
  const input = args as unknown as GetResultInput;

  if (!input.session_id) {
    throw new Error('session_id is required');
  }

  const session = getSession(input.session_id);
  if (!session) {
    throw new Error(`Session not found: ${input.session_id}`);
  }

  // Get the last Think agent response (the final refined analysis)
  const thinkAgent = session.agents.find(a => a.name === 'think') || session.agents[1];
  const thinkExchanges = session.exchanges.filter(e => e.agent === thinkAgent?.name);
  const finalThinkExchange = thinkExchanges[thinkExchanges.length - 1];

  if (!finalThinkExchange) {
    throw new Error('No reasoning exchanges found. Run run_reasoning_exchange first.');
  }

  // Calculate metrics
  const totalTokens = session.exchanges.reduce(
    (sum, e) => sum + e.tokens.input + e.tokens.output,
    0
  );

  const agentsUsed = [...new Set(session.exchanges.map(e => e.agent))];

  const qualityMetrics: QualityMetrics = {
    final_quality: session.currentQuality,
    iterations: session.currentIteration,
    total_tokens: totalTokens,
    agents_used: agentsUsed,
  };

  // Format result based on requested format
  let result: string;

  switch (input.format) {
    case 'json':
      result = JSON.stringify({
        topic: session.topic,
        analysis: finalThinkExchange.content,
        quality: session.currentQuality,
        iterations: session.currentIteration,
      }, null, 2);
      break;

    case 'structured':
      // Parse the markdown into sections
      result = formatStructured(session.topic, finalThinkExchange.content);
      break;

    case 'markdown':
    default:
      result = formatMarkdown(session.topic, finalThinkExchange.content, qualityMetrics);
      break;
  }

  const output: GetResultOutput = {
    session_id: session.id,
    status: session.status,
    result,
    quality_metrics: qualityMetrics,
  };

  if (input.include_full_exchange) {
    output.full_exchange = session.exchanges;
  }

  return {
    content: [
      {
        type: 'text',
        text: JSON.stringify(output, null, 2),
      },
    ],
  };
}

// ─────────────────────────────────────────────────────────────────────────────
// Formatting Helpers
// ─────────────────────────────────────────────────────────────────────────────

function formatMarkdown(topic: string, analysis: string, metrics: QualityMetrics): string {
  return `# Reasoning Result

**Topic:** ${topic}

**Quality Score:** ${(metrics.final_quality * 100).toFixed(0)}%
**Iterations:** ${metrics.iterations}
**Total Tokens:** ${metrics.total_tokens.toLocaleString()}

---

${analysis}

---

*Generated by Enclave Reasoning MCP using ${metrics.agents_used.join(' ↔ ')} dialogue*`;
}

function formatStructured(topic: string, analysis: string): string {
  // Extract sections from markdown
  const sections: Record<string, string> = {
    topic,
  };

  // Extract Title
  const titleMatch = analysis.match(/\*\*Title[:\s]*\*\*\s*(.+?)(?:\n|$)/i);
  if (titleMatch) sections.title = titleMatch[1].trim();

  // Extract Summary
  const summaryMatch = analysis.match(/\*\*Summary[:\s]*\*\*\s*(.+?)(?:\n\n|\*\*|$)/is);
  if (summaryMatch) sections.summary = summaryMatch[1].trim();

  // Extract Key Points
  const keyPointsMatch = analysis.match(/\*\*Key Points[:\s]*\*\*\s*([\s\S]+?)(?:\n\*\*|$)/i);
  if (keyPointsMatch) {
    const points = keyPointsMatch[1].match(/[-•]\s*(.+?)(?:\n|$)/g);
    if (points) {
      sections.keyPoints = points.map(p => p.replace(/^[-•]\s*/, '').trim()).join('\n');
    }
  }

  // Extract Requirements
  const reqMatch = analysis.match(/\*\*Requirements[:\s]*\*\*\s*([\s\S]+?)(?:\n\*\*|$)/i);
  if (reqMatch) {
    const reqs = reqMatch[1].match(/[-•]\s*(.+?)(?:\n|$)/g);
    if (reqs) {
      sections.requirements = reqs.map(r => r.replace(/^[-•]\s*/, '').trim()).join('\n');
    }
  }

  // Extract Constraints
  const constMatch = analysis.match(/\*\*Constraints[:\s]*\*\*\s*([\s\S]+?)(?:\n\*\*|$)/i);
  if (constMatch) {
    const consts = constMatch[1].match(/[-•]\s*(.+?)(?:\n|$)/g);
    if (consts) {
      sections.constraints = consts.map(c => c.replace(/^[-•]\s*/, '').trim()).join('\n');
    }
  }

  // Extract Success Criteria
  const criteriaMatch = analysis.match(/\*\*Success Criteria[:\s]*\*\*\s*([\s\S]+?)(?:\n\*\*|$)/i);
  if (criteriaMatch) {
    const criteria = criteriaMatch[1].match(/[-•]\s*(.+?)(?:\n|$)/g);
    if (criteria) {
      sections.successCriteria = criteria.map(c => c.replace(/^[-•]\s*/, '').trim()).join('\n');
    }
  }

  // Extract Next Steps
  const stepsMatch = analysis.match(/\*\*(?:Recommended )?Next Steps[:\s]*\*\*\s*([\s\S]+?)(?:\n\*\*|$)/i);
  if (stepsMatch) {
    const steps = stepsMatch[1].match(/[-•]\s*(.+?)(?:\n|$)/g);
    if (steps) {
      sections.nextSteps = steps.map(s => s.replace(/^[-•]\s*/, '').trim()).join('\n');
    }
  }

  // Extract Quality
  const qualityMatch = analysis.match(/\*\*Quality Assessment[:\s]*\*\*\s*(\d+\.?\d*)/i);
  if (qualityMatch) sections.quality = qualityMatch[1];

  return JSON.stringify(sections, null, 2);
}
